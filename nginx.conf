lua_package_path "/usr/local/openresty/lualib/?.lua;;";

server {
    listen 80;
    server_name _;

    # Serve the built Navia bundle under /navia/.
    location /navia/ {
        alias /usr/share/navia/;
        try_files $uri $uri/ =404;
        add_header Cache-Control "public, max-age=31536000, immutable" always;
    }

    location = /navia/index.html {
        alias /usr/share/navia/index.html;
        add_header Cache-Control "no-cache";
    }

    location / {
        proxy_pass https://eventflow.opensourcesantiago.io$request_uri;
        proxy_set_header Host eventflow.opensourcesantiago.io;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Accept-Encoding "";
        proxy_ssl_server_name on;

        header_filter_by_lua_block {
            local content_type = ngx.header["Content-Type"]
            if content_type and content_type:find("text/html", 1, true) then
                ngx.ctx.should_inject = true
                ngx.header["Content-Length"] = nil
            end
        }

        body_filter_by_lua_block {
            if not ngx.ctx.should_inject then
                return
            end

            local chunk = ngx.arg[1]
            local eof = ngx.arg[2]

            local buffer = ngx.ctx.buffered_body
            if not buffer then
                buffer = {}
                ngx.ctx.buffered_body = buffer
            end

            if chunk and chunk ~= "" then
                buffer[#buffer + 1] = chunk
            end

            if not eof then
                ngx.arg[1] = nil
                return
            end

            local body = table.concat(buffer)
            ngx.ctx.buffered_body = nil

            local injection = [[
<div id="navia-root"></div>
<script type="module">
(async () => {
  let mount = document.getElementById("navia-root");
  if (!mount) {
    mount = document.createElement("div");
    mount.id = "navia-root";
    document.body.appendChild(mount);
  }
  if (mount.dataset.naviaMounted === "true") {
    return;
  }
  mount.dataset.naviaMounted = "true";
  try {
    const response = await fetch("/navia/index.html", { cache: "no-store" });
    if (!response.ok) {
      throw new Error("Failed to load Navia shell");
    }
    const html = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    doc.querySelectorAll('link[rel="stylesheet"]').forEach((link) => {
      const href = link.getAttribute("href");
      if (!href) return;
      if (document.head.querySelector(`link[data-navia="${href}"]`)) {
        return;
      }
      const el = document.createElement("link");
      el.rel = "stylesheet";
      el.href = href;
      el.dataset.navia = href;
      document.head.appendChild(el);
    });
    doc.querySelectorAll('script[type="module"]').forEach((script) => {
      const src = script.getAttribute("src");
      if (!src) return;
      if (document.body.querySelector(`script[data-navia="${src}"]`)) {
        return;
      }
      const el = document.createElement("script");
      el.type = "module";
      el.src = src;
      el.dataset.navia = src;
      document.body.appendChild(el);
    });
  } catch (error) {
    console.error("Failed to bootstrap Navia", error);
  }
})();
</script>
]]

            local replaced, count = body:gsub("</body>", injection .. "</body>", 1)
            if count == 0 then
                replaced = body .. injection
            end

            ngx.arg[1] = replaced
            ngx.arg[2] = true
        }
    }
}
